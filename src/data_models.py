from __future__ import annotations as _annotations

from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field, SecretStr, AnyHttpUrl
from datetime import datetime, date, timezone
from enum import Enum
from uuid import UUID, uuid4


class TaskStatus(str, Enum):
    """Enumeration for task status values."""
    PENDING = "PENDING"
    IN_PROGRESS = "IN_PROGRESS"
    COMPLETED = "COMPLETED"
    BLOCKED = "BLOCKED"
    CANCELLED = "CANCELLED"
    DEFERRED = "DEFERRED"


class TaskPriority(str, Enum):
    """Enumeration for task priority values."""
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"


class ItemType(str, Enum):
    """Enumeration for the type of an item (Task or Subtask)."""
    TASK = "TASK"
    SUBTASK = "SUBTASK"


class Subtask(BaseModel):
    """Represents a subtask within a Task Master task."""
    id: UUID = Field(default_factory=uuid4,
                     description="Unique identifier for the subtask. Using RFC 4122 UUID format.")
    title: str = Field(description="Concise title of the subtask.")
    description: str = Field(
        description="Detailed description of the subtask, including its purpose and scope.")
    status: TaskStatus = TaskStatus.PENDING
    details: Optional[str] = Field(
        None, description="In-depth implementation notes or AI-generated content.")
    testStrategy: Optional[str] = Field(
        None, description="Proposed strategy for testing the subtask's completion.")
    dependencies: List[UUID] = Field(
        default_factory=list, description="List of unique identifiers for tasks or subtasks that must be completed before this subtask can begin. Dependencies create execution order constraints and are used for scheduling, progress tracking, and identifying potential blockers in the task workflow."
    )
    priority: TaskPriority = Field(
        TaskPriority.MEDIUM, description="Priority level of the subtask.")
    created_at: datetime = Field(default_factory=lambda: datetime.now(
        timezone.utc), description="Timestamp when the subtask was created.")
    updated_at: datetime = Field(default_factory=lambda: datetime.now(
        timezone.utc), description="Timestamp when the subtask was last updated.")
    due_date: Optional[date] = Field(
        None, description="Optional due date for the subtask, if applicable.")


class Task(BaseModel):
    """Represents a main task in the Task Master system."""
    id: UUID = Field(default_factory=uuid4,
                     description="Unique identifier for the task. Using RFC 4122 UUID format.")
    title: str = Field(description="Concise title of the task.")
    description: str = Field(
        description="Detailed description of the task, including its purpose and scope.")
    status: TaskStatus = Field(
        TaskStatus.PENDING, description="Current status of the task, indicating its progress in the workflow. If task is not started, it should be set to PENDING.")
    dependencies: List[UUID] = Field(
        default_factory=list, description="List of unique identifiers for tasks or subtasks that must be completed before this subtask can begin. Dependencies create execution order constraints and are used for scheduling, progress tracking, and identifying potential blockers in the task workflow."
    )
    priority: TaskPriority = Field(
        TaskPriority.MEDIUM, description="Priority level of the task.")
    details: Optional[str] = Field(
        None, description="In-depth implementation notes or AI-generated content.")
    testStrategy: Optional[str] = Field(
        None, description="Proposed strategy for testing the task's completion.")
    subtasks: List[Subtask] = Field(
        default_factory=list, description="List of subtasks for further decomposition.")
    complexity_score: Optional[int] = Field(
        None, description="Complexity score of the task, if calculated.")
    complexity_analysis_notes: Optional[str] = Field(
        None, description="Notes from the complexity analysis, if performed.")
    created_at: datetime = Field(default_factory=lambda: datetime.now(
        timezone.utc), description="Timestamp when the task was created.")
    updated_at: datetime = Field(default_factory=lambda: datetime.now(
        timezone.utc), description="Timestamp when the task was last updated.")
    due_date: Optional[date] = Field(
        None, description="Optional due date for the task, if applicable.")


class ProjectPlan(BaseModel):
    """Represents a comprehensive project plan generated by the agent."""
    id: UUID = Field(default_factory=uuid4,
                     description="Unique identifier for the project plan. Using RFC 4122 UUID format.")
    project_title: str = Field(description="The title of the project.")
    overall_goal: str = Field(
        description="The high-level goal of the project.")
    tasks: List[Task] = Field(
        default_factory=list, description="A structured list of tasks derived from the project goal.")
    notes: Optional[str] = Field(
        "", description="Any additional notes or considerations for the project plan.")
    project_name: Optional[str] = Field(
        None, description="Optional name for the project, if different from the title.")
    workspace_path: Optional[str] = Field(
        None, description="Path to the local workspace directory where project files are stored.")
    config_file_path: Optional[str] = Field(
        None, description="Path to the configuration file for the project.")
    last_complexity_analysis_timestamp: Optional[datetime] = Field(
        None, description="Timestamp of the last complexity analysis performed on the project plan.")
    version: str = "1.0.0"


class ModelConfig(BaseModel):
    """Configuration for a specific LLM model."""
    model_name: str
    provider: Optional[str] = None  # e.g., "ollama", "openai", "anthropic"
    api_key: Optional[SecretStr] = None
    base_url: Optional[AnyHttpUrl] = None
    # Add other provider-specific settings if needed


class AppConfig(BaseModel):
    """Overall application configuration."""
    main_model: ModelConfig
    research_model: Optional[ModelConfig] = None
    fallback_model: Optional[ModelConfig] = None
    project_plan_file: str = "project_plan.json"
    tasks_dir: str = "tasks"
    default_prd_filename: str = "prd.md"
    # Add other app-level settings from the plan as needed
